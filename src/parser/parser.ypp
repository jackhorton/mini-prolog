/*
 * bison parser generator for MiniProlog
 * CS 456
**/

%{
#include <cstdio>
#include <string>
#include <memory>
#include <iostream>

typedef void* yyscan_t;

#include "nodes/all.h"
#include "Dictionary.h"

void yyerror(void* scanner, char const * s) {
    fprintf(stderr, "%s\n", s);
}

#include "parser.h"
#include "lexer.h"
#include "parser_setup.h"

using namespace prolog::nodes;
using prolog::Dictionary;
using std::unique_ptr;
using std::string;

%}

%union {
    char const* string_val;
    prolog::nodes::AbstractNode* node;
}

/* we need full re-entrance to switch back and forth between query mode and rule mode */
%define      api.pure full
%lex-param   {yyscan_t scanner}
%parse-param {yyscan_t scanner}

%token<string_val> FULL_STOP LITERAL STRING_CONST LPAREN RPAREN AND

%type<node> fact;

%error-verbose

%%

program
    : statements { std::cout << "Parsed correctly" << std::endl; }
    ;
    
statements
    : statement FULL_STOP statements
    | /* empty */
    ;

statement
    : fact { Dictionary::get().insert($1); }
    /* | rule */
    ;

fact
    : LITERAL { $$ = new FactNode($1); }
    /* | LITERAL LPAREN arguments RPAREN { $$ = nullptr; } */
    ;

arguments
    : argument AND arguments
    | argument
    ;

argument
    : fact
    ;
