/*
 * bison parser generator for MiniProlog
 * CS 456
**/

%{
#include <cstdio>
#include <string>
#include <memory>
#include <iostream>

#include "nodes/all.h"
#include "Dictionary.h"

// making up for the unfortunate circumstances surrounding poorly-made GNU utilities
typedef void* yyscan_t;
void yyerror(void* scanner, char const * s) {
    fprintf(stderr, "%s\n", s);
}

#include "parser/NodeVector.h"
#include "parser/parser.h"
#include "parser/lexer.h"
#include "parser/fix.h"

using namespace prolog::nodes;
using prolog::Dictionary;
using prolog::NodeVector;

%}

%union {
    char const* string_val;
    prolog::nodes::AbstractNode* node;
    prolog::NodeVector* node_vec;
}

/* playing around with re-entrance */
%define      api.pure full
%lex-param   {yyscan_t scanner}
%parse-param {yyscan_t scanner}

%token<string_val> FULL_STOP LITERAL STRING_CONST LPAREN RPAREN AND

%type<node> fact argument;
%type<node_vec> arguments;

%error-verbose

%%

program
    : statements { std::cout << "Parsed correctly" << std::endl; }
    ;
    
statements
    : statement FULL_STOP statements
    | /* empty */
    ;

statement
    : fact { Dictionary::get().insert($1); }
    /* | rule */
    ;

fact
    : LITERAL                         { $$ = new FactNode($1); }
    | LITERAL LPAREN arguments RPAREN { $$ = new RelationNode($1, $3->get_vector()); delete $3; }
    ;

arguments
    : argument AND arguments { $$ = $3->push($1); }
    | argument               { $$ = (new NodeVector())->push($1); }
    ;

argument
    : fact { $$ = $1; }
    ;
